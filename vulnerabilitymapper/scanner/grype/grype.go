package grype

import (
	"encoding/json"
	"fmt"
	"os/exec"

	"github.com/anchore/grype/grype/presenter/models"
	"github.com/anchore/syft/syft/source"
	"github.com/deepfence/vulnerabilitymapper/scanner"
	"github.com/deepfence/vulnerabilitymapper/utils"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
)

const (
	RubyGemMatcher    string = "ruby-gem-matcher"
	JavaMatcher       string = "java-matcher"
	PythonMatcher     string = "python-matcher"
	JavascriptMatcher string = "javascript-matcher"
	MsrcMatcher       string = "msrc-matcher" //dotnet
)

// Scan calls the grype binary to scan the sbom
func Scan(bomPath string) ([]byte, error) {
	log.Infof("Scanning %s\n", bomPath)
	cm := fmt.Sprintf(`cat %s | grype -o json`, bomPath)
	// todo: implement(grype)
	cmd := exec.Command("bash", "-c", cm)
	return cmd.Output()
}

func Parse(p []byte) (models.Document, error) {
	doc := models.Document{}
	err := json.Unmarshal(p, &doc)
	return doc, errors.Wrap(err, "failed to parse grype output")
}

func PopulateFinalReport(p []byte, imageName string, imageID string, k8sClusterName string, scanID string) (string, error) {
	var cveJsonList string

	grypeDocument, err := Parse(p)
	if err != nil {
		return "", err
	}

	for _, match := range grypeDocument.Matches {
		description := match.Vulnerability.Description
		if description == "" {
			relatedVulnerabilities := match.RelatedVulnerabilities
			if len(relatedVulnerabilities) > 0 {
				description = relatedVulnerabilities[0].Description
			}
		}
		cveFixedInVersionList := match.Vulnerability.Fix.Versions
		cveFixedInVersion := ""
		if len(cveFixedInVersionList) != 0 {
			cveFixedInVersion = cveFixedInVersionList[0]
		}
		cveCVSSScoreList := match.Vulnerability.Cvss
		var cvssScore float64
		var overallScore float64
		var attackVector string
		if len(cveCVSSScoreList) == 0 {
			if len(match.RelatedVulnerabilities) > 0 {
				cvssScore, overallScore, attackVector = GetCvss(match.RelatedVulnerabilities[0].Cvss)
			}
		}

		report := scanner.VulnerabilityScanReport{}
		report.Cve_id = match.Vulnerability.ID
		report.Cve_type = getLanguageFromMatcher(match.MatchDetails[0].Matcher)
		report.Cve_container_image = imageName
		report.Cve_container_image_id = imageID
		report.Cve_container_name = imageName
		report.Cve_severity = match.Vulnerability.Severity
		report.Cve_caused_by_package = match.Artifact.Name + "_" + match.Artifact.Version
		report.Cve_caused_by_package_path = combinePaths(match.Artifact.Locations)
		report.Cve_container_layer = "Unknown" //todo
		report.Cve_fixed_in = cveFixedInVersion
		report.Cve_link = match.Vulnerability.DataSource
		report.Cve_description = description
		report.Cve_cvss_score = cvssScore
		report.Cve_attack_vector = attackVector
		report.Cve_overall_score = overallScore
		report.Scan_id = scanID
		report.KubernetesClusterName = k8sClusterName

		dfVulnerabilitiesStr, err := json.Marshal(report)
		if err != nil {
			return "", errors.Wrap(err, "failed to marshal vulnerability report")
		}
		if err == nil && string(dfVulnerabilitiesStr) != "" {
			cveJsonList += string(dfVulnerabilitiesStr) + ","
		}
	}

	return cveJsonList, nil
}

func getLanguageFromMatcher(matcher string) string {
	var MatcherToLanguage map[string]string = map[string]string{
		RubyGemMatcher:    "ruby",
		JavaMatcher:       "java",
		PythonMatcher:     "python",
		JavascriptMatcher: "js",
		MsrcMatcher:       "dotnet",
	}

	lang := MatcherToLanguage[matcher]
	if lang == "" {
		return "base"
	}
	return lang
}

func combinePaths(paths []source.Coordinates) string {
	var combinedPath string
	for _, path := range paths {
		combinedPath += path.RealPath + ":"
	}
	return utils.TrimSuffix(combinedPath, ":")
}
