/* eslint-disable no-unneeded-ternary */
/* eslint-disable no-nested-ternary */
import React, { useCallback, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import moment from 'moment';
import CveScanForm from './forms/cve-scan-form';
import { ScanFormAccordian, ScanHeadingDetails, ScanWraper } from './common';
import { cveScanInterimStatusUpdateAction, startCVEBulkAction, startCVEScanAction } from '../../../actions/app-actions';
import HorizontalLoader from '../../common/app-loader/horizontal-dots-loader';
import pollable from '../../common/header-view/pollable';
import { QueueCVEScan } from '../../../utils/web-api-utils';

const VulnerabilityScan = ({
  details,
  imageId,
  startPolling
}) => {
  const {
    parents = [],
  } = details;
  const dispatch = useDispatch();
  const [showAggregates, setShowAggregates] = useState(false);
  const { cveStore, aggregates, currentTopologyId } = useSelector((state) => {
    const cve = state.get('cve');
    return {
      cveStore: cve ? cve.toJS() : {},
      currentTopologyId: state.get('currentTopologyId'),
      aggregates: state.getIn(['cve', 'topology_cve_status', 'modal_view', 'aggregates']),
    }
  });

  let data = {};
  let error = {};
  if (cveStore.status && imageId) {
    const currentImageStatus = cveStore.status[imageId] ? cveStore.status[imageId] : {};
    data = currentImageStatus.data ? currentImageStatus.data : {};
    error = currentImageStatus.error ? currentImageStatus.error : {};
  }
  const showData = !Object.keys(error).length > 0;
  const { metadata } = details;
  const metadataIndex = metadata.reduce((acc, meta) => {
    acc[meta.id] = meta.value;
    return acc;
  }, {});
  const podParents = parents.filter(parent => parent.topologyId === 'pods');
  const hasPodAsParent = podParents.length > 0;
  const {
    user_defined_tags: userDefinedTags,
    kubernetes_cluster_id: kubeClusterId = '',
  } = metadataIndex;

  const startCVEBulk = useCallback((taglist, scanType) => {
    const params = {
      taglist,
      scanType,
      nodeType: details.type,
    }
    startPolling({ taglist });
    setShowAggregates(true);
    dispatch(startCVEBulkAction(params));
  }, [details]);

  const startCVEScanGeneric = useCallback(({
    taglist,
    scanType,
    imageId,
    scanThisCluster,
    scanThisNamespace,
    priority
  }) => {
    const params = {
      taglist,
      scanType,
      nodeType: details.type,
      nodeId: details.id,
      scanThisCluster,
      scanThisNamespace,
      priority
    }
    const promise = dispatch(startCVEScanAction(params));
    promise.then(() => {
      const now = moment().unix();
      dispatch(cveScanInterimStatusUpdateAction(imageId, {
        message: "Starting vulnerability scan. Please wait.",
        summary: 'Starting',
        showStop: false,
        showInProgress: true,
        userClickedTimestamp: now,
      }));
    }, (error) => {
      dispatch(cveScanInterimStatusUpdateAction(imageId, {
        error: {
          message: "Failed to start vulnerability scan",
          reason: error.responseText,
          showStart: true,
        },
        summary: 'Failed',
      }));
    });
    return promise;
  }, [details]);

  const cveStart = useCallback((valuesImmutable) => {
    let values = {}
    if (valuesImmutable.toJS) {
      values = valuesImmutable.toJS();
    }
    const {
      taglist = [],
      scanType,
      scanThisCluster = false,
      scanThisNamespace = false,
      priority
    } = values;
    const priorityValueCheck = !!(priority && priority.length > 0);
    const metaIndex = details.metadata.reduce((acc, el) => {
      acc[el.id] = el;
      return acc;
    }, {});

    let node_id = ""
    if (details.type === 'container' || details.type === 'container_image') {
      const {
        docker_image_name: {
          value: imageName = '',
        } = {},
        docker_image_tag: {
          value: imageTag = '',
        } = {},
      } = metaIndex;
      node_id = `${imageName}:${imageTag}`
    } else if (details.type === 'host') {
      for (let i = 0; i < details.metadata.length; i += 1) {
        if (details.metadata[i].id === "host_name") {
          node_id = details.metadata[i].value.trim();
          break;
        }
      }
    }

    const now = moment().unix();
    dispatch(cveScanInterimStatusUpdateAction(node_id, {
      showInProgress: true,
      summary: 'Starting',
      showStop: false,
      userClickedTimestamp: now,
    }));

    if (details.type === 'container_image' && taglist.length === 0) {
      return startCVEScanGeneric({ taglist, scanType, imageId: node_id });
    }

    if (taglist && taglist.length > 0) {
      startCVEBulk(taglist, scanType).then(
        () => {
          dispatch(cveScanInterimStatusUpdateAction(node_id, {
            message: "Starting vulnerability scan. Please wait.",
            summary: 'Starting',
            showStop: false,
            showInProgress: true,
            userClickedTimestamp: now,
          }));
        },
        (error) => {
          dispatch(cveScanInterimStatusUpdateAction(node_id, {
            error: {
              message: "Failed to start vulnerability scan",
              reason: error.responseText,
              showStart: true,
            },
            summary: 'Failed',
          }));
          let cve_scan_message = "";
          if (error.status === 400) {
            cve_scan_message = error.responseText
          }
          QueueCVEScan(node_id, "ERROR", cve_scan_message)
        }
      );
    } else {
      startCVEScanGeneric({ taglist, scanType, imageId: node_id, scanThisCluster, scanThisNamespace, priority: priorityValueCheck })
        .catch(() => {
          // QueueCVEScan(node_id, "ERROR", cve_scan_message); TODO
        });
    }
  }, [details]);


  return (
    <ScanWraper>
      <ScanHeadingDetails
        headingText="Vulnerability Scan"
        statusText={
          error?.message ? error?.message : (showData && data?.error?.message ? data.error.message : (showData && data.message ? data.message : ''))
        }
        isError={error?.message ? true : (showData && data?.error?.message ? true : false)}
        headingControl={
          <>
            {
              data.showStop && (
                <button
                  type="button"
                  className="primary-btn"
                  onClick={() => { }}
                  aria-hidden="true"
                >
                  Stop Scan
                </button>
              )
            }
            {data.showInProgress
              && (
                <HorizontalLoader style={{ position: 'static', fontSize: '26px', width: '40px' }} />
              )
            }
          </>
        }
      />
      <ScanFormAccordian label={!showAggregates && data.showStart ? "Configure and start" : null}>
        {
          data.showStart && (
            <CveScanForm
              onSubmit={cveStart}
              userDefinedTags={userDefinedTags}
              hasPodAsParent={hasPodAsParent}
              hasKubeClusterId={Boolean(kubeClusterId)}
            />
          )
        }
        {showAggregates
          && (
            <div className="scan-aggregates">
              <div className="info">
                Vulnerability scan started on
                {aggregates.TOTAL || 0}
                {' '}
                nodes
              </div>
              <div className="stats-container">
                <div className="stat">
                  <div>{aggregates.REQUEST_QUEUED || 0}</div>
                  <div>Queued</div>
                </div>
                <div className="stat">
                  <div>{aggregates.IN_PROGRESS || 0}</div>
                  <div>On-going</div>
                </div>
                <div className="stat">
                  <div>{aggregates.ERROR || 0}</div>
                  <div>Error</div>
                </div>
                <div className="stat">
                  <div>{aggregates.COMPLETED || 0}</div>
                  <div>Completed</div>
                </div>
              </div>
            </div>
          )
        }
      </ScanFormAccordian>
    </ScanWraper>
  );
};


const PollableVunlerabilityScan = pollable({
  pollingIntervalInSecs: 3,
})(VulnerabilityScan);

export { PollableVunlerabilityScan as VulnerabilityScan }
