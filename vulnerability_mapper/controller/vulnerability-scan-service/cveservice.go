package vulnerability_scan_service

import (
	"fmt"
	"github.com/deepfence/vulnerability_mapper/scanner/grype"
	"github.com/deepfence/vulnerability_mapper/utils"
	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"net/http"
	"os"
	"time"
)

func New() *VulnerabilityScanService {
	return &VulnerabilityScanService{}
}

// Scan is a handler function for the /vulnerability-scan endpoint
// It takes a sbom and returns a json document containing the cve information
// e.g.
//	curl --location --request POST 'http://127.0.0.1:8085/vulnerability-mapper-api/vulnerability-scan?image-name=dum-im&image-id=abc1234&scan-id=xyz456' \
//	--header 'Content-Type: application/json' \
//	--data-raw '/*sbom json*/'
func (c *VulnerabilityScanService) Scan(gc *gin.Context) {
	// userInput is a vulnerability sbom in json format
	sbom, err := gc.GetRawData()
	if err != nil {
		fmt.Println(err)
		gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	}

	imageName := gc.Query("image_name")
	imageID := gc.Query("image_id")
	k8sClusterName := gc.Query("kubernetes_cluster_name")
	scanId := gc.Query("scan_id")
	hostName := gc.Query("host_name")
	nodeId := gc.Query("node_id")
	nodeType := gc.Query("node_type")
	scanType := gc.Query("scan_type")
	containerName := gc.Query("container_name")

	// validate sbom and return error if invalid
	if err := utils.ValidateSbom(sbom); err != nil {
		gc.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		log.Errorf("Invalid sbom: %s", err.Error())
		return
	}

	stopLogging := make(chan bool)

	go func() {
		utils.IngestScanStatus("", "STARTED", scanId, nodeType, nodeId, scanType, hostName, k8sClusterName)
		ticker := time.NewTicker(2 * time.Minute)
		for {
			select {
			case <-ticker.C:
				utils.IngestScanStatus("", "SCAN_IN_PROGRESS", scanId, nodeType, nodeId, scanType, hostName, k8sClusterName)
			case <-stopLogging:
				return
			}
		}
	}()

	// start a go routine here
	go func() {
		logError := func(errMsg string) {
			log.Error(errMsg)
			stopLogging <- true
			time.Sleep(3 * time.Second)
			err = utils.IngestScanStatus(errMsg, "ERROR", scanId, nodeType, nodeId, scanType, hostName, k8sClusterName)
			if err != nil {
				log.Errorf("Error while ingesting: %s", err)
			}
		}

		// create a temporary file to store the user input(SBOM)
		file, err := utils.TempSBOMFile(sbom)
		if err != nil {
			errMsg := fmt.Sprintf("Error creating temp file: %s\n", err)
			logError(errMsg)
			return
		}

		defer os.Remove(file.Name())

		outputBytes, err := grype.Scan(file.Name())
		if err != nil {
			errMsg := fmt.Sprintf("Error while scanning: %s\n", err)
			logError(errMsg)
			return
		}

		report, err := grype.PopulateFinalReport(outputBytes, imageName, imageID, k8sClusterName, scanId, nodeType, nodeId, hostName, containerName)
		if err != nil {
			errMsg := fmt.Sprintf("Error while populating final report: %s", err)
			logError(errMsg)
			return
		}

		s := fmt.Sprintf("[%s]", utils.TrimSuffix(report, ","))
		err = utils.Ingest(s)
		if err != nil {
			errMsg := fmt.Sprintf("Error while ingesting: %s", err)
			logError(errMsg)
			return
		}

		completeScan := func() {
			stopLogging <- true
			time.Sleep(3 * time.Second)
			err = utils.IngestScanStatus("", "COMPLETED", scanId, nodeType, nodeId, scanType, hostName, k8sClusterName)
			if err != nil {
				log.Errorf("Error while ingesting: %s", err)
			}
		}

		completeScan()
		log.Infof("Scan completed for image: %s", imageName)
	}()
	gc.JSON(http.StatusOK, gin.H{"status": "scan started"})
}
