package grype

import (
	"encoding/json"
	"fmt"
	"github.com/anchore/grype/grype/presenter/models"
	"github.com/anchore/syft/syft/source"
	"github.com/deepfence/vulnerability_mapper/scanner"
	"github.com/deepfence/vulnerability_mapper/utils"
	"github.com/pkg/errors"
	"os/exec"
)

const (
	RubyGemMatcher    string = "ruby-gem-matcher"
	JavaMatcher       string = "java-matcher"
	PythonMatcher     string = "python-matcher"
	JavascriptMatcher string = "javascript-matcher"
	MsrcMatcher       string = "msrc-matcher" //dotnet
)

// Scan calls the grype binary to scan the sbom
func Scan(bomPath string) ([]byte, error) {
	cm := fmt.Sprintf(`cat %s | grype -o json`, bomPath)
	// todo: implement(grype)
	cmd := exec.Command("bash", "-c", cm)
	return cmd.Output()
}

func Parse(p []byte) (models.Document, error) {
	doc := models.Document{}
	err := json.Unmarshal(p, &doc)
	return doc, errors.Wrap(err, "failed to parse grype output")
}

func PopulateFinalReport(p []byte, imageName string, imageID string, k8sClusterName string, scanID string, nodeType string, nodeId string, hostName string) (string, error) {
	var cveJsonList string

	grypeDocument, err := Parse(p)
	if err != nil {
		return "", err
	}

	for _, match := range grypeDocument.Matches {
		description := match.Vulnerability.Description
		if description == "" {
			relatedVulnerabilities := match.RelatedVulnerabilities
			if len(relatedVulnerabilities) > 0 {
				description = relatedVulnerabilities[0].Description
			}
		}
		cveFixedInVersionList := match.Vulnerability.Fix.Versions
		cveFixedInVersion := ""
		if len(cveFixedInVersionList) != 0 {
			cveFixedInVersion = cveFixedInVersionList[0]
		}
		cveCVSSScoreList := match.Vulnerability.Cvss
		var cvssScore float64
		var overallScore float64
		var attackVector string
		if len(cveCVSSScoreList) == 0 {
			if len(match.RelatedVulnerabilities) > 0 {
				cvssScore, overallScore, attackVector = GetCvss(match.RelatedVulnerabilities[0].Cvss)
			}
		}

		report := scanner.VulnerabilityScanReport{
			Type:                   "cve",
			Masked:                 "false",
			Host:                   hostName,
			NodeType:               nodeType,
			NodeId:                 nodeId,
			HostName:               hostName,
			KubernetesClusterName:  k8sClusterName,
			ScanId:                 scanID,
			CveId:                  match.Vulnerability.ID,
			CveType:                getLanguageFromMatcher(match.MatchDetails[0].Matcher),
			CveContainerImage:      imageName,
			CveContainerImageId:    imageID,
			CveContainerName:       "",
			CveSeverity:            match.Vulnerability.Severity,
			CveCausedByPackage:     match.Artifact.Name + "_" + match.Artifact.Version,
			CveCausedByPackagePath: combinePaths(match.Artifact.Locations),
			CveContainerLayer:      "",
			CveFixedIn:             cveFixedInVersion,
			CveLink:                match.Vulnerability.DataSource,
			CveDescription:         description,
			CveCvssScore:           cvssScore,
			CveOverallScore:        overallScore,
			CveAttackVector:        attackVector,
		}
		dfVulnerabilitiesStr, err := json.Marshal(report)
		if err != nil {
			return "", errors.Wrap(err, "failed to marshal vulnerability report")
		}
		if err == nil && string(dfVulnerabilitiesStr) != "" {
			cveJsonList += string(dfVulnerabilitiesStr) + ","
		}
	}

	return cveJsonList, nil
}

func getLanguageFromMatcher(matcher string) string {
	var MatcherToLanguage map[string]string = map[string]string{
		RubyGemMatcher:    "ruby",
		JavaMatcher:       "java",
		PythonMatcher:     "python",
		JavascriptMatcher: "js",
		MsrcMatcher:       "dotnet",
	}

	lang := MatcherToLanguage[matcher]
	if lang == "" {
		return "base"
	}
	return lang
}

func combinePaths(paths []source.Coordinates) string {
	var combinedPath string
	for _, path := range paths {
		combinedPath += path.RealPath + ":"
	}
	return utils.TrimSuffix(combinedPath, ":")
}
